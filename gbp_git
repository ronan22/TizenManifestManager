#!/bin/bash

# A simple script to checkout or update a svn or git repo as source service
#
# (C) 2010 by Adrian Schr√∂ter <adrian@suse.de>
#  
# This program is free software; you can redistribute it and/or  
# modify it under the terms of the GNU General Public License  
# as published by the Free Software Foundation; either version 2  
# of the License, or (at your option) any later version.  
# See http://www.gnu.org/licenses/gpl-2.0.html for full license text.  

SERVICE='gbp_git'

CACHEDIRECTORY="/srv/obs/CACHEDIRECTORY"

for DIRECTORY in incoming repo repourl ; do
  if [ -d ${CACHEDIRECTORY}/${DIRECTORY} ]; then
    mkdir -p ${CACHEDIRECTORY}/${DIRECTORY} ;
  fi
done

set_default_params () {
  MYSCM="git"
  MYURL=""
  MYFILENAME=""
  MYREVISION=""
  GIT_CLONE="git clone"
}

get_config_options () {
  # config options for this host ?
  if [ -f /etc/obs/services/$SERVICE ]; then
    . /etc/obs/services/$SERVICE
  fi
  
}

parse_params () {
  while test $# -gt 0; do
    case $1 in

      *-url)
        MYURL="$2"
        shift
      ;;
      *-revision)
        MYREVISION="$2"
        shift
      ;;
      *-filename)
        MYFILENAME="${2#/}"
        shift
      ;;
      *-package_name)
        PACKAGE_NAME="$2"
        shift
      ;;
      *-outdir)
        MYOUTDIR="$2"
        shift
      ;;
      *-specFile)
        USE_SPECFILE="$2"
        shift
      ;;
      *-gbp_option)
        GBP_OPTION="$2"
        shift
      ;;
      *)
        echo "Unknown parameter: $1"
        echo 'Usage: $SERVICE  --url $URL  [--revision $REVISION]  [--package_name $PACKAGE_NAME] --outdir $OUT'
        exit 1
      ;;
    esac
    shift
  done
}

error () {
  echo "ERROR: $*"
  exit 1
}

debug () {
  [ -n "$DEBUG_GBP_GIT" ] && echo "$*"
}

safe_run () {
  if ! "$@"; then
    error "$* failed; aborting!"
  fi
}

sanitise_params () {

  if [ -z "$MYURL" ]; then
    error "no checkout URL is given via --url parameter!"
  fi
  if [ -z "$MYOUTDIR" ]; then
    error "no output directory is given via --outdir parameter!"
  fi
  if [ -z "$MYREVISION" ]; then
    error "no revision is given via --revision parameter!"
  fi
  if [ -z "$PACKAGE_NAME" ]; then
    error "no package_name is given via --package_name parameter!"
  fi

  FILE="$MYFILENAME"

}

detect_default_filename_param () {
  if [ -n "$FILE" ]; then
    return
  fi

  FILE="${MYURL%/}"
  FILE="${FILE##*/}"
  FILE="${FILE%.git}"
  FILE="${FILE#*@*:}"

}

fetch_upstream () {
  TOHASH="$MYURL"
  HASH=`echo "$TOHASH" | sha256sum | cut -d\  -f 1`
  REPOCACHE=
  if [ -n "$CACHEDIRECTORY" ]; then
    REPOCACHEINCOMING="$CACHEDIRECTORY/incoming"
    REPOCACHEROOT="$CACHEDIRECTORY/repo"
    REPOCACHE="$REPOCACHEROOT/$HASH"
    REPOURLCACHE="$CACHEDIRECTORY/repourl/$HASH"
  fi

  if [ -z "$MYREVISION" ]; then
    MYREVISION=master
  fi

  debug "check local cache if configured"
  if [ -n "$CACHEDIRECTORY" -a -d "$REPOCACHE/.$MYSCM" ]; then
    debug "cache hit: $REPOCACHE/.$MYSCM"
    check_cache
    echo "Found $TOHASH in $REPOCACHE; updating ..."
    update_cache
    REPOPATH="$REPOCACHE"
  else
    if [ -n "$CACHEDIRECTORY" ]; then
      debug "cache miss: $REPOCACHE/.$MYSCM"
    else
      debug "cache not enabled"
    fi

    calc_dir_to_clone_to
    debug "new $MYSCM checkout to $CLONE_TO"
    initial_clone

    if [ -n "$CACHEDIRECTORY" ]; then
      cache_repo
      REPOPATH="$REPOCACHE"
    else
      REPOPATH="$MYOUTDIR/$FILE"
    fi
  fi

  safe_run cd "$REPOPATH"
  switch_to_revision
}

calc_dir_to_clone_to () {
  if [ -n "$CACHEDIRECTORY" ]; then
    safe_run cd "$REPOCACHEINCOMING"
    # Use dry-run mode because git/hg refuse to clone into
    # an empty directory on SLES11
    debug mktemp -u -d "tmp.XXXXXXXXXX"
    CLONE_TO=`mktemp -u -d "tmp.XXXXXXXXXX"`
  else
    CLONE_TO="$FILE"
  fi
}

initial_clone () {
  echo "Fetching from $MYURL ..."

  # Clone with full depth; so that the revision can be found if specified
  safe_run ${GIT_CLONE} "$MYURL" "$CLONE_TO"

}

cache_repo () {
  if [ -e "$REPOCACHE" ]; then
    error "Somebody else beat us to populating the cache for $MYURL ($REPOCACHE)"
  else
    # FIXME: small race window here; do source services need to be thread-safe?
    debug mv2 "$CLONE_TO" "$REPOCACHE"
    safe_run mv "$CLONE_TO" "$REPOCACHE"
    echo "$MYURL" > "$REPOURLCACHE"
    echo "Cached $MYURL at $REPOCACHE"
  fi
}

check_cache () {
  CACHEDURL=`cat "$REPOURLCACHE"`
  [ -z "$CACHEDURL" ] && CACHEDURL='<unknown URL>'
  if [ "$MYURL" != "$CACHEDURL" ]; then
    error "Corrupt cache: cache for repo $MYURL was recorded as being from $CACHEDURL"
  fi
}

update_cache () {
  safe_run cd "$REPOCACHE"

  safe_run git fetch --all

}

switch_to_revision () {
      # $MYREVISION may refer to any of the following:
      #
      # - explicit SHA1: a1b2c3d4....
      #   - the SHA1 must be reachable from a default clone/fetch (generally, must be
      #     reachable from some branch or tag on the remote).
      #   - set by: git checkout <SHA1>
      #
      # - short branch name: "master", "devel" etc.
      #   - set by: git checkout <branch> && git pull
      #
      # - explicit ref: refs/heads/master, refs/tags/v1.2.3, refs/changes/49/11249/1
      #   - set by: git fetch <url> +<revision>:<revision> && git checkout <revision>
      #
      if ! git checkout "$MYREVISION"; then
	echo "$MYREVISION not accessible by default clone/fetch, attempting explicit fetch"
        safe_run git fetch "$MYURL" "+$MYREVISION:$MYREVISION"
        git checkout "$MYREVISION"
        echo "reset to origin/$MYREVISION"
	safe_run git reset --hard  "origin/$MYREVISION"
      fi
      if git branch | grep -q '^\* (no branch)$'; then
        echo "$MYREVISION does not refer to a branch, not attempting git pull"
      else
	echo "reset to origin/$MYREVISION"
	safe_run git reset --hard  "origin/$MYREVISION"
        safe_run git pull
      fi
}

prep_tree_for_tar () {
  if [ ! -e "$REPOPATH/$MYSUBDIR" ]; then
    error "directory does not exist: $REPOPATH/$MYSUBDIR"
  fi

  TAR_BASENAME="$FILE"


  MYINCLUDES=""

  if [ -z "$MYINCLUDES" ]; then
    MYINCLUDES="$TAR_BASENAME"
  fi

  safe_run cd "$MYOUTDIR"

  if [ -n "$CACHEDIRECTORY" ]; then
    debug cp -a "$REPOPATH/$MYSUBDIR" "$TAR_BASENAME"
    safe_run cp -a "$REPOPATH/$MYSUBDIR" "$TAR_BASENAME"
  else
    debug mv3 "$REPOPATH/$MYSUBDIR" "$TAR_BASENAME"
    safe_run mv "$REPOPATH/$MYSUBDIR" "$TAR_BASENAME"
  fi
}

cleanup () {
  debug rm -rf "$TAR_BASENAME"
  rm -rf $TAR_BASENAME
}

create_gbp () {
   safe_run cd $TAR_BASENAME
   
   if [ -z "$USE_SPECFILE" ] ; then
      echo find_spec_file ${TAR_BASENAME} ${PACKAGE_NAME} > /tmp/test_log
      
      USE_SPECFILE=`find_spec_file ${MYOUTDIR}/${TAR_BASENAME} ${PACKAGE_NAME}`
   fi  
   
   git-buildpackage-rpm export --git-export-only --git-ignore-new --git-builder=osc --git-upstream-branch=upstream --git-export-dir="$MYOUTDIR" --git-packaging-dir=packaging --git-export="$MYREVISION" --git-upstream-branch=upstream --git-upstream-tag="upstream/%( )s" --git-spec-file="$USE_SPECFILE" $GBP_OPTION || exit 1


   safe_run cd ..
}

main () {
  set_default_params

  get_config_options

  parse_params "$@"
  sanitise_params

  SRCDIR=$(pwd)
  cd "$MYOUTDIR"
  detect_default_filename_param

  fetch_upstream
 
  prep_tree_for_tar
  
  create_gbp
  
  cleanup
}

main "$@"

exit 0
